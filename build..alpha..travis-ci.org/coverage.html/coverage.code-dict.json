{"/home/travis/build/npmtest/node-npmtest-pcap/test.js":"/* istanbul instrument in package npmtest_pcap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pcap/lib.npmtest_pcap.js":"/* istanbul instrument in package npmtest_pcap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_pcap = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_pcap = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-pcap/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-pcap && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_pcap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_pcap\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_pcap.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_pcap.rollup.js'] =\n            local.assetsDict['/assets.npmtest_pcap.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_pcap.__dirname + '/lib.npmtest_pcap.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/pcap.js":"var util          = require(\"util\");\nvar events        = require(\"events\");\nvar binding       = require(\"./build/Release/pcap_binding\");\nvar SocketWatcher = require(\"socketwatcher\").SocketWatcher;\nvar decode        = require(\"./decode\").decode;\nvar tcp_tracker   = require(\"./tcp_tracker\");\nvar DNSCache      = require(\"./dns_cache\");\n\nexports.decode = decode;\nexports.TCPTracker = tcp_tracker.TCPTracker;\nexports.TCPSession = tcp_tracker.TCPSession;\nexports.DNSCache = DNSCache;\n\nfunction PcapSession(is_live, device_name, filter, buffer_size, outfile, is_monitor) {\n    this.is_live = is_live;\n    this.device_name = device_name;\n    this.filter = filter || \"\";\n    this.buffer_size = buffer_size;\n    this.outfile = outfile || \"\";\n    this.is_monitor = Boolean(is_monitor);\n\n    this.link_type = null;\n    this.fd = null;\n    this.opened = null;\n    this.buf = null;\n    this.header = null;\n    this.read_watcher = null;\n    this.empty_reads = 0;\n    this.packets_read = null;\n\n    this.session = new binding.PcapSession();\n\n    if (typeof this.buffer_size === \"number\" && !isNaN(this.buffer_size)) {\n        this.buffer_size = Math.round(this.buffer_size);\n    } else {\n        this.buffer_size = 10 * 1024 * 1024; // Default buffer size is 10MB\n    }\n\n    var self = this;\n\n    // called for each packet read by pcap\n    function packet_ready() {\n        self.on_packet_ready();\n    }\n\n    if (this.is_live) {\n        this.device_name = this.device_name || binding.default_device();\n        this.link_type = this.session.open_live(this.device_name, this.filter, this.buffer_size, this.outfile, packet_ready, this.is_monitor);\n    } else {\n        this.link_type = this.session.open_offline(this.device_name, this.filter, this.buffer_size, this.outfile, packet_ready, this.is_monitor);\n    }\n\n    this.fd = this.session.fileno();\n    this.opened = true;\n    this.buf = new Buffer(this.buffer_size || 65535);\n    this.header = new Buffer(16);\n\n    if (is_live) {\n        this.readWatcher = new SocketWatcher();\n\n        // readWatcher gets a callback when pcap has data to read. multiple packets may be readable.\n        this.readWatcher.callback = function pcap_read_callback() {\n            var packets_read = self.session.dispatch(self.buf, self.header);\n            if (packets_read < 1) {\n                this.empty_reads += 1;\n            }\n        };\n        this.readWatcher.set(this.fd, true, false);\n        this.readWatcher.start();\n    } else {\n        setImmediate(function() {\n            var packets = 0;\n            do {\n                packets = self.session.dispatch(self.buf, self.header);\n            } while ( packets > 0 );\n            self.emit(\"complete\");\n        });\n    }\n\n    events.EventEmitter.call(this);\n}\nutil.inherits(PcapSession, events.EventEmitter);\n\nexports.lib_version = binding.lib_version();\n\nPcapSession.prototype.findalldevs = function () {\n    return binding.findalldevs();\n};\n\nfunction PacketWithHeader(buf, header, link_type) {\n    this.buf = buf;\n    this.header = header;\n    this.link_type = link_type;\n}\n\nPcapSession.prototype.on_packet_ready = function () {\n    var full_packet = new PacketWithHeader(this.buf, this.header, this.link_type);\n    this.emit(\"packet\", full_packet);\n};\n\nPcapSession.prototype.close = function () {\n    this.opened = false;\n    this.session.close();\n    this.readWatcher.stop();\n    // TODO - remove listeners so program will exit I guess?\n};\n\nPcapSession.prototype.stats = function () {\n    return this.session.stats();\n};\n\nPcapSession.prototype.inject = function (data) {\n    return this.session.inject(data);\n};\n\nexports.Pcap = PcapSession;\nexports.PcapSession = PcapSession;\n\nexports.createSession = function (device, filter, buffer_size, monitor) {\n    return new PcapSession(true, device, filter, buffer_size, null, monitor);\n};\n\nexports.createOfflineSession = function (path, filter) {\n    return new PcapSession(false, path, filter, 0, null, null);\n};\n\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/dns_cache.js":"var dns = require(\"dns\");\n\n// cache reverse DNS lookups for the life of the program. No TTL checking. No tricks.\n\nfunction DNSCache() {\n    this.cache = {};\n    this.requests = {};\n}\n\nDNSCache.prototype.ptr = function (ip) {\n    if (this.cache[ip]) {\n        return this.cache[ip];\n    }\n\n    if (this.requests[ip] === undefined) {\n        this.requests[ip] = true;\n        var self = this;\n        dns.reverse(ip, function (err, domains) {\n            self.on_ptr(err, ip, domains);\n        });\n    }\n\n    return ip;\n};\n\nDNSCache.prototype.on_ptr = function (err, ip, domains) {\n    // TODO - check for network and broadcast addrs, since we have iface info\n    if (err) {\n        this.cache[ip] = ip;\n    } else {\n        this.cache[ip] = domains[0];\n    }\n};\n\nmodule.exports = DNSCache;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/tcp_tracker.js":"var EventEmitter = require(\"events\").EventEmitter;\nvar inherits = require(\"util\").inherits;\nvar IPv4 = require(\"./decode/ipv4\");\nvar TCP = require(\"./decode/tcp\");\n\nfunction TCPTracker() {\n    this.sessions = {};\n    EventEmitter.call(this);\n}\ninherits(TCPTracker, EventEmitter);\n\nTCPTracker.prototype.track_packet = function (packet) {\n    var ip, tcp, src, dst, key, session;\n\n    if (packet.payload.payload instanceof IPv4 && packet.payload.payload.payload instanceof TCP) {\n        ip  = packet.payload.payload;\n        tcp = ip.payload;\n        src = ip.saddr + \":\" + tcp.sport;\n        dst = ip.daddr + \":\" + tcp.dport;\n\n        if (src < dst) {\n            key = src + \"-\" + dst;\n        } else {\n            key = dst + \"-\" + src;\n        }\n\n        var is_new = false;\n        session = this.sessions[key];\n        if (! session) {\n            is_new = true;\n            session = new TCPSession();\n            this.sessions[key] = session;\n        }\n\n        session.track(packet);\n\n        // need to track at least one packet before we emit this new session, otherwise nothing\n        // will be initialized.\n        if (is_new) {\n            this.emit(\"session\", session);\n        }\n    }\n    // silently ignore any non IPv4 TCP packets\n    // user should filter these out with their pcap filter, but oh well.\n};\n\nfunction TCPSession() {\n    this.src = null;\n    this.src_name = null; // from DNS\n    this.dst = null;\n    this.dst_name = null; // from DNS\n\n    this.state = null;\n    this.current_cap_time = null;\n\n    this.syn_time = null;\n    this.missed_syn = null;\n    this.connect_time = null;\n\n    this.send_isn = null;\n    this.send_window_scale = null;\n    this.send_packets = {}; // send_packets is indexed by the expected ackno: seqno + length\n    this.send_acks = {};\n    this.send_retrans = {};\n    this.send_next_seq = null;\n    this.send_acked_seq = null;\n    this.send_bytes_ip = null;\n    this.send_bytes_tcp = null;\n    this.send_bytes_payload = 0;\n\n    this.recv_isn = null;\n    this.recv_window_scale = null;\n    this.recv_packets = {};\n    this.recv_acks = {};\n    this.recv_retrans = {};\n    this.recv_next_seq = null;\n    this.recv_acked_seq = null;\n    this.recv_bytes_ip = 0;\n    this.recv_bytes_tcp = 0;\n    this.recv_bytes_payload = 0;\n\n    EventEmitter.call(this);\n}\ninherits(TCPSession, EventEmitter);\n\nTCPSession.prototype.track = function (packet) {\n    var ip  = packet.payload.payload;\n    var tcp = ip.payload;\n    var src = ip.saddr + \":\" + tcp.sport;\n    var dst = ip.daddr + \":\" + tcp.dport;\n\n    this.current_cap_time = packet.pcap_header.tv_sec + (packet.pcap_header.tv_usec / 1000000);\n\n    if (this.state === null) {\n        this.src = src; // the side the sent the first packet we saw\n        this.src_name = src;\n        this.dst = dst; // the side that the first packet we saw was sent to\n        this.dst_name = dst;\n\n        if (tcp.flags.syn && !tcp.flags.ack) { // initial SYN, best case\n            this.state = \"SYN_SENT\";\n        } else { // joining session already in progress\n            this.missed_syn = true;\n            this.connect_time = this.current_cap_time;\n            this.state = \"ESTAB\";  // I mean, probably established, right? Unless it isn't.\n        }\n\n        this.syn_time = this.current_cap_time;\n        this.send_isn = tcp.seqno;\n        this.send_window_scale = tcp.options.window_scale || 1; // multipler, not bit shift value\n        this.send_next_seq = tcp.seqno + 1;\n        this.send_bytes_ip = ip.header_bytes;\n        this.send_bytes_tcp = tcp.header_bytes;\n    } else if (tcp.flags.syn && !tcp.flags.ack) {\n        this.emit(\"syn retry\", this);\n    } else { // not a SYN, so run the state machine\n        this[this.state](packet);\n    }\n};\n\nTCPSession.prototype.SYN_SENT = function (packet) {\n    var ip  = packet.payload.payload;\n    var tcp = ip.payload;\n    var src = ip.saddr + \":\" + tcp.sport;\n\n    if (src === this.dst && tcp.flags.syn && tcp.flags.ack) {\n        this.recv_bytes_ip += ip.header_bytes;\n        this.recv_bytes_tcp += tcp.header_bytes;\n        this.recv_packets[tcp.seqno + 1] = this.current_cap_time;\n        this.recv_acks[tcp.ackno] = this.current_cap_time;\n        this.recv_isn = tcp.seqno;\n        this.recv_window_scale = tcp.options.window_scale || 1;\n        this.state = \"SYN_RCVD\";\n    } else if (tcp.flags.rst) {\n        this.state = \"CLOSED\";\n        this.emit(\"reset\", this, \"recv\"); // TODO - check which direction did the reset, probably recv\n//    } else {\n//        console.log(\"Didn't get SYN-ACK packet from dst while handshaking: \" + util.inspect(tcp, false, 4));\n    }\n};\n\nTCPSession.prototype.SYN_RCVD = function (packet) {\n    var ip  = packet.payload.payload;\n    var tcp = ip.payload;\n    var src = ip.saddr + \":\" + tcp.sport;\n\n    if (src === this.src && tcp.flags.ack) { // TODO - make sure SYN flag isn't set, also match src and dst\n        this.send_bytes_ip += ip.header_bytes;\n        this.send_bytes_tcp += tcp.header_bytes;\n        this.send_acks[tcp.ackno] = this.current_cap_time;\n        this.connect_time = this.current_cap_time;\n        this.emit(\"start\", this);\n        this.state = \"ESTAB\";\n//    } else {\n//        console.log(\"Didn't get ACK packet from src while handshaking: \" + util.inspect(tcp, false, 4));\n    }\n};\n\n// TODO - actually implement SACK decoding and tracking\n// if (tcp.options.sack) {\n//     console.log(\"SACK magic, handle this: \" + util.inspect(tcp.options.sack));\n//     console.log(util.inspect(ip, false, 5));\n// }\n// TODO - check for tcp.flags.rst and emit reset event\n\nTCPSession.prototype.ESTAB = function (packet) {\n    var ip  = packet.payload.payload;\n    var tcp = ip.payload;\n    var src = ip.saddr + \":\" + tcp.sport;\n\n    if (src === this.src) { // this packet came from the active opener / client\n        this.send_bytes_ip += ip.header_bytes;\n        this.send_bytes_tcp += tcp.header_bytes;\n        if (tcp.data_bytes) {\n            if (this.send_packets[tcp.seqno + tcp.data_bytes]) {\n                this.emit(\"retransmit\", this, \"send\", tcp.seqno + tcp.data_bytes);\n                if (this.send_retrans[tcp.seqno + tcp.data_bytes]) {\n                    this.send_retrans[tcp.seqno + tcp.data_bytes] += 1;\n                } else {\n                    this.send_retrans[tcp.seqno + tcp.data_bytes] = 1;\n                }\n            } else {\n                this.emit(\"data send\", this, tcp.data);\n            }\n            this.send_bytes_payload += tcp.data_bytes;\n            this.send_packets[tcp.seqno + tcp.data_bytes] = this.current_cap_time;\n        }\n        if (this.recv_packets[tcp.ackno]) {\n            this.send_acks[tcp.ackno] = this.current_cap_time;\n        }\n        // console.log(\"sending ACK for packet we didn't see received: \" + tcp.ackno);\n        if (tcp.flags.fin) {\n            this.state = \"FIN_WAIT\";\n        }\n    } else if (src === this.dst) { // this packet came from the passive opener / server\n        this.recv_bytes_ip += ip.header_bytes;\n        this.recv_bytes_tcp += tcp.header_bytes;\n        if (tcp.data_bytes) {\n            if (this.recv_packets[tcp.seqno + tcp.data_bytes]) {\n                this.emit(\"retransmit\", this, \"recv\", tcp.seqno + tcp.data_bytes);\n                if (this.recv_retrans[tcp.seqno + tcp.data_bytes]) {\n                    this.recv_retrans[tcp.seqno + tcp.data_bytes] += 1;\n                } else {\n                    this.recv_retrans[tcp.seqno + tcp.data_bytes] = 1;\n                }\n            } else {\n                this.emit(\"data recv\", this, tcp.data);\n            }\n            this.recv_bytes_payload += tcp.data_bytes;\n            this.recv_packets[tcp.seqno + tcp.data_bytes] = this.current_cap_time;\n        }\n        if (this.send_packets[tcp.ackno]) {\n            this.recv_acks[tcp.ackno] = this.current_cap_time;\n        }\n        if (tcp.flags.fin) {\n            this.state = \"CLOSE_WAIT\";\n        }\n    } else {\n        console.log(\"non-matching packet in session: \" + packet);\n    }\n};\n\n// TODO - need to track half-closed data\nTCPSession.prototype.FIN_WAIT = function (packet) {\n    var ip  = packet.payload.payload;\n    var tcp = ip.payload;\n    var src = ip.saddr + \":\" + tcp.sport;\n\n    if (src === this.dst && tcp.flags.fin) {\n        this.state = \"CLOSING\";\n    }\n};\n\n// TODO - need to track half-closed data\nTCPSession.prototype.CLOSE_WAIT = function (packet) {\n    var ip  = packet.payload.payload;\n    var tcp = ip.payload;\n    var src = ip.saddr + \":\" + tcp.sport;\n\n    if (src === this.src && tcp.flags.fin) {\n        this.state = \"LAST_ACK\";\n    }\n};\n\n// TODO - need to track half-closed data\nTCPSession.prototype.LAST_ACK = function (packet) {\n    var ip  = packet.payload.payload;\n    var tcp = ip.payload;\n    var src = ip.saddr + \":\" + tcp.sport;\n\n    if (src === this.dst) {\n        this.close_time = this.current_cap_time;\n        this.state = \"CLOSED\";\n        this.emit(\"end\", this);\n    }\n};\n\n// TODO - need to track half-closed data\nTCPSession.prototype.CLOSING = function (packet) {\n    var ip  = packet.payload.payload;\n    var tcp = ip.payload;\n    var src = ip.saddr + \":\" + tcp.sport;\n\n    if (src === this.src) {\n        this.close_time = this.current_cap_time;\n        this.state = \"CLOSED\";\n        this.emit(\"end\", this);\n    }\n};\n\n// The states aren't quite right here.  All possible states of FIN and FIN/ACKs aren't handled.\n// So some of the bytes of the session may not be properly accounted for.\n\nTCPSession.prototype.CLOSED = function (packet) {\n    // not sure what to do here. We are closed, so I guess bump some counters or something.\n};\n\nTCPSession.prototype.session_stats = function () {\n    var send_acks = Object.keys(this.send_acks)\n        .map(function (key) { return +key; })\n        .sort(function (a, b) { return a > b; });\n    var recv_acks = Object.keys(this.recv_acks)\n        .map(function (key) { return +key; })\n        .sort(function (a, b) { return a > b; });\n\n    var total_time = this.close_time - this.syn_time;\n    var stats = {};\n    var self = this;\n\n    stats.recv_times = {};\n    send_acks.forEach(function (v) {\n        if (self.recv_packets[v]) {\n            stats.recv_times[v] = self.send_acks[v] - self.recv_packets[v];\n        }\n    });\n\n    stats.send_times = {};\n    recv_acks.forEach(function (v) {\n        if (self.send_packets[v]) {\n            stats.send_times[v] = self.recv_acks[v] - self.send_packets[v];\n        }\n    });\n\n    stats.send_retrans = {};\n    Object.keys(this.send_retrans).forEach(function (v) {\n        stats.send_retrans[v] = self.send_retrans[v];\n    });\n\n    stats.recv_retrans = {};\n    Object.keys(this.recv_retrans).forEach(function (v) {\n        stats.recv_retrans[v] = self.recv_retrans[v];\n    });\n\n    stats.connect_duration = this.connect_time - this.syn_time;\n    stats.total_time = total_time;\n    stats.send_overhead = this.send_bytes_ip + this.send_bytes_tcp;\n    stats.send_payload = this.send_bytes_payload;\n    stats.send_total = stats.send_overhead + stats.send_payload;\n    stats.recv_overhead = this.recv_bytes_ip + this.recv_bytes_tcp;\n    stats.recv_payload = this.recv_bytes_payload;\n    stats.recv_total = stats.recv_overhead + stats.recv_payload;\n\n    return stats;\n};\n\nexports.TCPSession = TCPSession;\nexports.TCPTracker = TCPTracker;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/ipv4.js":"var ICMP = require(\"./icmp\");\nvar IGMP = require(\"./igmp\");\nvar TCP = require(\"./tcp\");\nvar UDP = require(\"./udp\");\nvar IPv6 = require(\"./ipv6\");\nvar IPv4Addr = require(\"./ipv4_addr\");\n\nfunction IPFlags() {\n    this.reserved = null;\n    this.df = null;\n    this.mf = null;\n}\n\nIPFlags.prototype.toString = function () {\n    var ret = \"[\";\n    if (this.reserved) {\n        ret += \"r\";\n    }\n    if (this.df) {\n        ret += \"d\";\n    }\n    if (this.mf) {\n        ret += \"m\";\n    }\n    ret += \"]\";\n    return ret;\n};\n\nfunction IPv4() {\n    this.version = null;\n    this.header_length = null;\n    this.header_bytes = null; // not part of packet, but handy\n    this.diffserv = null;\n    this.total_length = null;\n    this.identification = null;\n    this.flags = new IPFlags();\n    this.fragment_offset = null;\n    this.ttl = null;\n    this.protocol = null;\n    this.header_checksum = null;\n    this.saddr = null;\n    this.daddr = null;\n    this.protocol_name = null;\n    this.payload = null;\n}\n\n// http://en.wikipedia.org/wiki/IPv4\nIPv4.prototype.decode = function (raw_packet, offset) {\n    var orig_offset = offset;\n\n    this.version = (raw_packet[offset] & 240) >> 4; // first 4 bits\n    this.header_length = raw_packet[offset] & 15; // second 4 bits\n    this.header_bytes = this.header_length * 4;\n    offset += 1;\n    this.diffserv = raw_packet[offset];\n    offset += 1;\n    this.total_length = raw_packet.readUInt16BE(offset, true);\n    offset += 2;\n    this.identification = raw_packet.readUInt16BE(offset, true);\n    offset += 2;\n    this.flags.reserved = (raw_packet[offset] & 128) >> 7;\n    this.flags.df = (raw_packet[offset] & 64) >> 6;\n    this.flags.mf = (raw_packet[offset] & 32) >> 5;\n    this.fragment_offset = ((raw_packet[offset] & 31) * 256) + raw_packet[offset + 1]; // 13-bits from 6, 7\n    offset += 2;\n    this.ttl = raw_packet[offset];\n    offset += 1;\n    this.protocol = raw_packet[offset];\n    offset += 1;\n    this.header_checksum = raw_packet.readUInt16BE(offset, true);\n    offset += 2;\n    this.saddr = new IPv4Addr(raw_packet, offset);\n    offset += 4;\n    this.daddr = new IPv4Addr(raw_packet, offset);\n    offset += 4;\n\n    // TODO - parse IP \"options\" if header_length > 5\n\n    offset = orig_offset + (this.header_length * 4);\n\n    switch (this.protocol) {\n    case 1:\n        this.payload = new ICMP();\n        this.payload.decode(raw_packet, offset);\n        break;\n    case 2:\n        this.payload = new IGMP().decode(raw_packet, offset);\n        break;\n    case 4:\n        this.payload = new IPv4().decode(raw_packet, offset);\n        break;\n    case 6:\n        this.payload = new TCP().decode(raw_packet, offset, this.total_length - this.header_bytes);\n        break;\n    case 17:\n        this.payload = new UDP().decode(raw_packet, offset);\n        break;\n    case 41:\n        this.payload = new IPv6().decode(raw_packet, offset);\n        break;\n    default:\n        this.protocol_name = \"Unknown\";\n    }\n\n    return this;\n};\n\nIPv4.prototype.toString = function () {\n    var ret = this.saddr + \" -> \" + this.daddr;\n    var flags = this.flags.toString();\n    if (flags.length > 2) {\n        ret += \" flags \" + flags;\n    }\n\n    switch (this.protocol) {\n    case 1:\n        ret += \" ICMP\";\n        break;\n    case 2:\n        ret += \" IGMP\";\n        break;\n    case 4:\n        ret += \" IPv4_in_IPv4\"; // IPv4 encapsulation, RFC2003\n        break;\n    case 6:\n        ret += \" TCP\";\n        break;\n    case 17:\n        ret += \" UDP\";\n        break;\n    case 41:\n        ret += \" IPv6_in_IP4\"; // IPv6 encapsulation, RFC2473\n        break;\n    default:\n        ret += \" proto \" + this.protocol;\n    }\n\n    return ret + \" \" + this.payload;\n};\n\nmodule.exports = IPv4;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/icmp.js":"function ICMP() {\n    this.type = null;\n    this.code = null;\n    this.checksum = null;\n    this.id = null;\n    this.sequence = null;\n}\n\n// http://en.wikipedia.org/wiki/Internet_Control_Message_Protocol\nICMP.prototype.decode = function (raw_packet, offset) {\n    this.type = raw_packet[offset];\n    this.code = raw_packet[offset + 1];\n    this.checksum = raw_packet.readUInt16BE(offset + 2); // 2, 3\n    this.id = raw_packet.readUInt16BE(offset + 4); // 4, 5\n    this.sequence = raw_packet.readUInt16BE(offset + 6); // 6, 7\n\n    return this;\n};\n\nICMP.prototype.toString = function () {\n    var ret = \"\";\n\n    switch (this.type) {\n    case 0:\n        ret += \"Echo Reply\";\n        break;\n    case 1:\n    case 2:\n        ret += \"Reserved\";\n        break;\n    case 3: // destination unreachable\n        switch (this.code) {\n        case 0:\n            ret += \"Destination Network Unreachable\";\n            break;\n        case 1:\n            ret += \"Destination Host Unreachable\";\n            break;\n        case 2:\n            ret += \"Destination Protocol Unreachable\";\n            break;\n        case 3:\n            ret += \"Destination Port Unreachable\";\n            break;\n        case 4:\n            ret += \"Fragmentation required, and DF flag set\";\n            break;\n        case 5:\n            ret += \"Source route failed\";\n            break;\n        case 6:\n            ret += \"Destination network unknown\";\n            break;\n        case 7:\n            ret += \"Destination host unknown\";\n            break;\n        case 8:\n            ret += \"Source host isolated\";\n            break;\n        case 9:\n            ret += \"Network administratively prohibited\";\n            break;\n        case 10:\n            ret += \"Host administratively prohibited\";\n            break;\n        case 11:\n            ret += \"Network unreachable for TOS\";\n            break;\n        case 12:\n            ret += \"Host unreachable for TOS\";\n            break;\n        case 13:\n            ret += \"Communication administratively prohibited\";\n            break;\n        default:\n            ret += \"Destination Unreachable (unknown code \" + this.code + \")\";\n        }\n        break;\n    case 4:\n        ret += \"Source Quench\";\n        break;\n    case 5: // redirect\n        switch (ret.code) {\n        case 0:\n            ret += \"Redirect Network\";\n            break;\n        case 1:\n            ret += \"Redirect Host\";\n            break;\n        case 2:\n            ret += \"Redirect TOS and Network\";\n            break;\n        case 3:\n            ret += \"Redirect TOS and Host\";\n            break;\n        default:\n            ret += \"Redirect (unknown code \" + ret.code + \")\";\n            break;\n        }\n        break;\n    case 6:\n        ret += \"Alternate Host Address\";\n        break;\n    case 7:\n        ret += \"Reserved\";\n        break;\n    case 8:\n        ret += \"Echo Request\";\n        break;\n    case 9:\n        ret += \"Router Advertisement\";\n        break;\n    case 10:\n        ret += \"Router Solicitation\";\n        break;\n    case 11:\n        switch (this.code) {\n        case 0:\n            ret += \"TTL expired in transit\";\n            break;\n        case 1:\n            ret += \"Fragment reassembly time exceeded\";\n            break;\n        default:\n            ret += \"Time Exceeded (unknown code \" + this.code + \")\";\n        }\n        break;\n        // TODO - decode the rest of the well-known ICMP messages, even though they are deprecated\n    default:\n        ret += \"type \" + this.type + \" code \" + this.code;\n    }\n\n    // TODO - there are often more exciting things hiding in ICMP packets after the headers\n    return ret;\n};\n\nmodule.exports = ICMP;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/igmp.js":"function IGMP() {\n    this.type = null;\n    this.version = null;\n    this.max_response_time = null;\n    this.checksum = null;\n    this.group_address = null;\n}\n\nvar IPV4Addr = require(\"./ipv4_addr\");\n\n// http://en.wikipedia.org/wiki/Internet_Group_Management_Protocol\nIGMP.prototype.decode = function (raw_packet, offset) {\n    this.type = raw_packet[offset];\n    this.max_response_time = raw_packet[offset + 1];\n    this.checksum = raw_packet.readUInt16BE(offset + 2); // 2, 3\n    this.group_address = new IPV4Addr(raw_packet, offset + 4); // 4, 5, 6, 7\n\n    switch (this.type) {\n    case 0x11:\n        this.version = this.max_response_time > 0 ? 2 : 1;\n        break;\n    case 0x12:\n        this.version = 1;\n        break;\n    case 0x16:\n        this.version = 2;\n        break;\n    case 0x17:\n        this.version = 2;\n        break;\n    case 0x22:\n        this.version = 3;\n        break;\n    default:\n        break;\n    }\n\n    return this;\n};\n\nIGMP.prototype.toString = function () {\n    var ret;\n\n    switch (this.type) {\n    case 0x11:\n        ret = \"Membership Query\";\n        break;\n    case 0x12:\n        ret = \"Membership Report\";\n        break;\n    case 0x16:\n        ret = \"Membership Report\";\n        break;\n    case 0x17:\n        ret = \"Leave Group\";\n        break;\n    case 0x22:\n        ret = \"Membership Report\";\n        // TODO: Decode v3 message\n        break;\n    default:\n        ret = \"type \" + this.type;\n        break;\n    }\n\n    return ret;\n};\n\nmodule.exports = IGMP;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/ipv4_addr.js":"var map = require(\"../util\").int8_to_dec;\n\nfunction IPv4Addr(raw_packet, offset) {\n\tthis.o1\t= raw_packet[offset];\n\tthis.o2\t= raw_packet[offset + 1];\n\tthis.o3\t= raw_packet[offset + 2];\n\tthis.o4\t= raw_packet[offset + 3];\n}\n\n// Don't use Array.prototype.join here, because string concat is much faster\nIPv4Addr.prototype.toString = function () {\n    return map[this.o1] + \".\" + map[this.o2] + \".\" + map[this.o3] + \".\" + map[this.o4];\n};\n\nmodule.exports = IPv4Addr;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/util.js":"function lpad(str, len) {\n    while (str.length < len) {\n        str = \"0\" + str;\n    }\n    return str;\n}\n\nexports.dump_bytes = function dump_bytes(raw_packet, offset) {\n    for (var i = offset; i < raw_packet.pcap_header.caplen ; i += 1) {\n        console.log(i + \": \" + raw_packet[i]);\n    }\n};\n\nvar int8_to_hex = [];\nvar int8_to_hex_nopad = [];\nvar int8_to_dec = [];\n\nfor (var i = 0; i <= 255; i++) {\n    int8_to_hex[i] = lpad(i.toString(16), 2);\n    int8_to_hex_nopad[i] = i.toString(16);\n    int8_to_dec[i] = i.toString();\n}\n\nexports.int8_to_dec = int8_to_dec;\nexports.int8_to_hex = int8_to_hex;\nexports.int8_to_hex_nopad = int8_to_hex_nopad;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/tcp.js":"\nfunction TCPFlags() {\n    this.cwr = null;\n    this.ece = null;\n    this.urg = null;\n    this.ack = null;\n    this.psh = null;\n    this.rst = null;\n    this.syn = null;\n    this.fin = null;\n}\n\nTCPFlags.prototype.toString = function () {\n    var ret = \"[\";\n\n    if (this.cwr) {\n        ret += \"c\";\n    }\n    if (this.ece) {\n        ret += \"e\";\n    }\n    if (this.urg) {\n        ret += \"u\";\n    }\n    if (this.ack) {\n        ret += \"a\";\n    }\n    if (this.psh) {\n        ret += \"p\";\n    }\n    if (this.rst) {\n        ret += \"r\";\n    }\n    if (this.syn) {\n        ret += \"s\";\n    }\n    if (this.fin) {\n        ret += \"f\";\n    }\n    ret += \"]\";\n\n    return ret;\n};\n\nfunction TCPOptions() {\n    this.mss = null;\n    this.window_scale = null;\n    this.sack_ok = null;\n    this.sack = null;\n    this.timestamp = null;\n    this.echo = null;\n}\n\nTCPOptions.prototype.decode = function (raw_packet, offset, len) {\n    var end_offset = offset + len;\n\n    while (offset < end_offset) {\n        switch (raw_packet[offset]) {\n        case 0: // end of options list\n            offset = end_offset;\n            break;\n        case 1: // NOP / padding\n            offset += 1;\n            break;\n        case 2:\n            offset += 2;\n            this.mss = raw_packet.readUInt16BE(offset);\n            offset += 2;\n            break;\n        case 3:\n            offset += 2;\n            this.window_scale = raw_packet[offset];\n            offset += 1;\n            break;\n        case 4:\n            this.sack_ok = true;\n            offset += 2;\n            break;\n        case 5:\n            this.sack = [];\n            offset += 1;\n            switch (raw_packet[offset]) {\n            case 10:\n                offset += 1;\n                this.sack.push([raw_packet.readUInt32BE(offset), raw_packet.readUInt32BE(offset + 4)]);\n                offset += 8;\n                break;\n            case 18:\n                offset += 1;\n                this.sack.push([raw_packet.readUInt32BE(offset), raw_packet.readUInt32BE(offset + 4)]);\n                offset += 8;\n                this.sack.push([raw_packet.readUInt32BE(offset), raw_packet.readUInt32BE(offset + 4)]);\n                offset += 8;\n                break;\n            case 26:\n                offset += 1;\n                this.sack.push([raw_packet.readUInt32BE(offset), raw_packet.readUInt32BE(offset + 4)]);\n                offset += 8;\n                this.sack.push([raw_packet.readUInt32BE(offset), raw_packet.readUInt32BE(offset + 4)]);\n                offset += 8;\n                this.sack.push([raw_packet.readUInt32BE(offset), raw_packet.readUInt32BE(offset + 4)]);\n                offset += 8;\n                break;\n            case 34:\n                offset += 1;\n                this.sack.push([raw_packet.readUInt32BE(offset), raw_packet.readUInt32BE(offset + 4)]);\n                offset += 8;\n                this.sack.push([raw_packet.readUInt32BE(offset), raw_packet.readUInt32BE(offset + 4)]);\n                offset += 8;\n                this.sack.push([raw_packet.readUInt32BE(offset), raw_packet.readUInt32BE(offset + 4)]);\n                offset += 8;\n                this.sack.push([raw_packet.readUInt32BE(offset), raw_packet.readUInt32BE(offset + 4)]);\n                offset += 8;\n                break;\n            default:\n                console.log(\"Invalid TCP SACK option length \" + raw_packet[offset + 1]);\n                offset = end_offset;\n            }\n            break;\n        case 8:\n            offset += 2;\n            this.timestamp = raw_packet.readUInt32BE(offset);\n            offset += 4;\n            this.echo = raw_packet.readUInt32BE(offset);\n            offset += 4;\n            break;\n        default:\n            throw new Error(\"Don't know how to process TCP option \" + raw_packet[offset]);\n        }\n    }\n\n    return this;\n};\n\nTCPOptions.prototype.toString = function () {\n    var ret = \"\";\n    if (this.mss !== null) {\n        ret += \"mss:\" + this.mss + \" \";\n    }\n    if (this.window_scale !== null) {\n        ret += \"scale:\" + this.window_scale + \"(\" + Math.pow(2, (this.window_scale)) + \") \";\n    }\n    if (this.sack_ok !== null) {\n        ret += \"sack_ok\" + \" \";\n    }\n    if (this.sack !== null) {\n        ret += \"sack:\" + this.sack.join(\",\") + \" \";\n    }\n\n    if (ret.length === 0) {\n        ret = \". \";\n    }\n\n    return \"[\" + ret.slice(0, -1) + \"]\";\n};\n\nfunction TCP() {\n    this.sport          = null;\n    this.dport          = null;\n    this.seqno          = null;\n    this.ackno          = null;\n    this.data_offset    = null;\n    this.header_bytes   = null; // not part of packet but handy\n    this.reserved       = null;\n    this.flags          = new TCPFlags();\n    this.window_size    = null;\n    this.checksum       = null;\n    this.urgent_pointer = null;\n    this.options        = null;\n    this.data           = null;\n    this.data_bytes     = null;\n}\n\n// If you get stuck trying to decode or understand the offset math, stick this block in to dump the contents:\n// for (var i = orig_offset; i < orig_offset + len ; i++) {\n//     console.log((i - orig_offset) + \" / \" + i + \": \" + raw_packet[i] + \" \" + String.fromCharCode(raw_packet[i]));\n// }\n\n// http://en.wikipedia.org/wiki/Transmission_Control_Protocol\nTCP.prototype.decode = function (raw_packet, offset, len) {\n    var orig_offset = offset;\n\n    this.sport          = raw_packet.readUInt16BE(offset, true); // 0, 1\n    offset += 2;\n    this.dport          = raw_packet.readUInt16BE(offset, true); // 2, 3\n    offset += 2;\n    this.seqno          = raw_packet.readUInt32BE(offset, true); // 4, 5, 6, 7\n    offset += 4;\n    this.ackno          = raw_packet.readUInt32BE(offset, true); // 8, 9, 10, 11\n    offset += 4;\n    this.data_offset    = (raw_packet[offset] & 0xf0) >> 4; // first 4 bits of 12\n    if (this.data_offset < 5 || this.data_offset > 15) {\n        throw new Error(\"invalid data_offset: \" + this.data_offset);\n    }\n    this.header_bytes   = this.data_offset * 4; // convenience for using data_offset\n    this.reserved       = raw_packet[offset] & 15; // second 4 bits of 12\n    offset += 1;\n    var all_flags = raw_packet[offset];\n    this.flags.cwr      = (all_flags & 128) >> 7; // all flags packed into 13\n    this.flags.ece      = (all_flags & 64) >> 6;\n    this.flags.urg      = (all_flags & 32) >> 5;\n    this.flags.ack      = (all_flags & 16) >> 4;\n    this.flags.psh      = (all_flags & 8) >> 3;\n    this.flags.rst      = (all_flags & 4) >> 2;\n    this.flags.syn      = (all_flags & 2) >> 1;\n    this.flags.fin      = all_flags & 1;\n    offset += 1;\n    this.window_size    = raw_packet.readUInt16BE(offset, true); // 14, 15\n    offset += 2;\n    this.checksum       = raw_packet.readUInt16BE(offset, true); // 16, 17\n    offset += 2;\n    this.urgent_pointer = raw_packet.readUInt16BE(offset, true); // 18, 19\n    offset += 2;\n\n    this.options = new TCPOptions();\n    var options_len = this.header_bytes - (offset - orig_offset);\n    if (options_len > 0) {\n        this.options.decode(raw_packet, offset, options_len);\n        offset += options_len;\n    }\n\n    this.data_bytes = len - this.header_bytes;\n    if (this.data_bytes > 0) {\n        // add a buffer slice pointing to the data area of this TCP packet.\n        // Note that this does not make a copy, so ret.data is only valid for this current\n        // trip through the capture loop.\n        this.data = raw_packet.slice(offset, offset + this.data_bytes);\n    }\n\n    return this;\n};\n\nTCP.prototype.toString = function () {\n    var ret = this.sport + \"->\" + this.dport + \" seq \" + this.seqno + \" ack \" + this.ackno + \" flags \" + this.flags + \" \" +\n        \"win \" + this.window_size + \" csum \" + this.checksum;\n    if (this.urgent_pointer) {\n        ret += \" urg \" + this.urgent_pointer;\n    }\n    ret += \" \" + this.options.toString();\n    ret += \" len \" + this.data_bytes;\n    return ret;\n};\n\n// automatic protocol decode ends here.  Higher level protocols can be decoded by using payload.\n\nmodule.exports = TCP;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/udp.js":"var DNS = require(\"./dns\");\n\nfunction UDP() {\n    this.sport = null;\n    this.dport = null;\n    this.length = null;\n    this.checksum = null;\n    this.data = null;\n}\n\n// http://en.wikipedia.org/wiki/User_Datagram_Protocol\nUDP.prototype.decode = function (raw_packet, offset) {\n    this.sport = raw_packet.readUInt16BE(offset, true);\n    offset += 2;\n    this.dport = raw_packet.readUInt16BE(offset, true);\n    offset += 2;\n    this.length = raw_packet.readUInt16BE(offset, true);\n    offset += 2;\n    this.checksum = raw_packet.readUInt16BE(offset, true);\n    offset += 2;\n\n    this.data = raw_packet.slice(offset, offset + (this.length - 8));\n\n    return this;\n};\n\nUDP.prototype.toString = function () {\n    var ret = \"UDP \" + this.sport + \"->\" + this.dport + \" len \" + this.length;\n    if (this.sport === 53 || this.dport === 53) {\n        ret += (new DNS().decode(this.data, 0, this.data.length).toString());\n    }\n    return ret;\n};\n\nmodule.exports = UDP;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/dns.js":"var IPv4Addr = require(\"./ipv4_addr\");\nvar IPv6Addr = require(\"./ipv6_addr\");\n\nfunction DNSHeader(raw_packet, offset) {\n    this.id = raw_packet.readUInt16BE(offset); // 0, 1\n    this.qr = (raw_packet[offset + 2] & 128) >> 7;\n    this.opcode = (raw_packet[offset + 2] & 120) >> 3;\n    this.aa = (raw_packet[offset + 2] & 4) >> 2;\n    this.tc = (raw_packet[offset + 2] & 2) >> 1;\n    this.rd = raw_packet[offset + 2] & 1;\n    this.ra = (raw_packet[offset + 3] & 128) >> 7;\n    this.z = 0; // spec says this MUST always be 0\n    this.rcode = raw_packet[offset + 3] & 15;\n    this.qdcount = raw_packet.readUInt16BE(offset + 4); // 4, 5\n    this.ancount = raw_packet.readUInt16BE(offset + 6); // 6, 7\n    this.nscount = raw_packet.readUInt16BE(offset + 8); // 8, 9\n    this.arcount = raw_packet.readUInt16BE(offset + 10); // 10, 11\n}\n\nDNSHeader.prototype.toString = function () {\n    return \"{\" +\n        \" id:\" + this.id +\n        \" qr:\" + this.qr +\n        \" op:\" + this.opcode +\n        \" aa:\" + this.aa +\n        \" tc:\" + this.tc +\n        \" rd:\" + this.rd +\n        \" ra:\" + this.ra +\n        \" rc:\" + this.rcode +\n        \" qd:\" + this.qdcount +\n        \" an:\" + this.ancount +\n        \" ns:\" + this.nscount +\n        \" ar:\" + this.arcount +\n        \" }\";\n};\n\nfunction DNS() {\n    this.header = null;\n    this.question = null;\n    this.answer = null;\n    this.authority = null;\n    this.additional = null;\n\n    // not part of DNS, but handy so we don't have to pass these around all over the place\n    this.raw_packet = null;\n    this.offset = null;\n    this.packet_start = null;\n    this.packet_len = null;\n}\n\nfunction DNSRRSet(count) {\n    this.rrs = new Array(count);\n}\n\nDNSRRSet.prototype.toString = function () {\n    return this.rrs.join(\", \");\n};\n\n// http://tools.ietf.org/html/rfc1035\nDNS.prototype.decode = function (raw_packet, offset, caplen) {\n    this.raw_packet = raw_packet;\n    this.packet_start = offset;\n    this.offset = offset;\n    this.packet_len = caplen;\n\n    this.header = new DNSHeader(raw_packet, this.offset);\n    this.offset += 12;\n\n    this.question = this.decode_RRs(this.header.qdcount, true);\n    this.answer = this.decode_RRs(this.header.ancount, false);\n    this.authority = this.decode_RRs(this.header.nscount, false);\n    this.additional = this.decode_RRs(this.header.arcount, false);\n\n    return this;\n};\n\nDNS.prototype.decode_RRs = function (count, is_question) {\n    if (count > 100) {\n        throw new Error(\"Malformed DNS packet: too many RRs at offset \" + this.offset);\n    }\n\n    var ret = new DNSRRSet(count);\n    for (var i = 0; i < count; i++) {\n        ret.rrs[i] = this.decode_RR(is_question);\n    }\n    return ret;\n};\n\nfunction DNSRR(is_question) {\n    this.name = \"\";\n    this.type = null;\n    this.class = null;\n    this.ttl = null;\n    this.rdlength = null;\n    this.rdata = null;\n    this.is_question = is_question;\n}\n\nDNSRR.prototype.toString = function () {\n    var ret = this.name + \" \";\n    if (this.is_question) {\n        ret += qtype_to_string(this.type) + \" \" + qclass_to_string(this.class);\n    } else {\n        ret += type_to_string(this.type) + \" \" + class_to_string(this.class) + \" \" + this.ttl + \" \" + this.rdata;\n    }\n    return ret;\n};\n\nDNS.prototype.read_name = function () {\n    var result = \"\";\n    var len_or_ptr;\n    var pointer_follows = 0;\n    var pos = this.offset;\n\n    while ((len_or_ptr = this.raw_packet[pos]) !== 0x00) {\n        if ((len_or_ptr & 0xC0) === 0xC0) {\n            // pointer is bottom 6 bits of current byte, plus all 8 bits of next byte\n            pos = ((len_or_ptr & ~0xC0) << 8) | this.raw_packet[pos + 1];\n            pointer_follows++;\n            if (pointer_follows === 1) {\n                this.offset += 2;\n            }\n            if (pointer_follows > 5) {\n                throw new Error(\"invalid DNS RR: too many compression pointers found at offset \" + pos);\n            }\n        } else {\n            if (result.length > 0) {\n                result += \".\";\n            }\n            if (len_or_ptr > 63) {\n                throw new Error(\"invalid DNS RR: length is too large at offset \" + pos);\n            }\n            pos++;\n            for (var i = pos; i < (pos + len_or_ptr) && i < this.packet_len ; i++) {\n                if (i > this.packet_len) {\n                    throw new Error(\"invalid DNS RR: read beyond end of packet at offset \" + i);\n                }\n                var ch = this.raw_packet[i];\n                result += String.fromCharCode(ch);\n            }\n            pos += len_or_ptr;\n\n            if (pointer_follows === 0) {\n                this.offset = pos;\n            }\n        }\n    }\n\n    if (pointer_follows === 0) {\n        this.offset++;\n    }\n\n    return result;\n};\n\nDNS.prototype.decode_RR = function (is_question) {\n    if (this.offset > this.packet_len) {\n        throw new Error(\"Malformed DNS RR. Offset is beyond packet len (decode_RR) :\" + this.offset + \" packet_len:\" + this.packet_len);\n    }\n\n    var rr = new DNSRR(is_question);\n\n    rr.name = this.read_name();\n\n    rr.type = this.raw_packet.readUInt16BE(this.offset);\n    this.offset += 2;\n    rr.class = this.raw_packet.readUInt16BE(this.offset);\n    this.offset += 2;\n    if (is_question) {\n        return rr;\n    }\n\n    rr.ttl = this.raw_packet.readUInt32BE(this.offset);\n    this.offset += 4;\n    rr.rdlength = this.raw_packet.readUInt16BE(this.offset);\n    this.offset += 2;\n\n    if (rr.type === 1 && rr.class === 1 && rr.rdlength) { // A, IN\n        rr.rdata = new IPv4Addr(this.raw_packet, this.offset);\n    } else if (rr.type === 2 && rr.class === 1) { // NS, IN\n        rr.rdata = this.read_name();\n        this.offset -= rr.rdlength; // read_name moves offset\n    } else if (rr.type === 28 && rr.class === 1 && rr.rdlength === 16) {\n        rr.data = new IPv6Addr(this.raw_packet, this.offset);\n    }\n    // TODO - decode other rr types\n\n    this.offset += rr.rdlength;\n\n    return rr;\n};\n\nDNS.prototype.toString = function () {\n    var ret = \" DNS \";\n\n    ret += this.header.toString();\n    if (this.header.qdcount > 0) {\n        ret += \"\\n  question:\" + this.question.rrs[0];\n    }\n    if (this.header.ancount > 0) {\n        ret += \"\\n  answer:\" + this.answer;\n    }\n    if (this.header.nscount > 0) {\n        ret += \"\\n  authority:\" + this.authority;\n    }\n    if (this.header.arcount > 0) {\n        ret += \"\\n  additional:\" + this.additional;\n    }\n\n    return ret;\n};\n\nfunction type_to_string(type_num) {\n    switch (type_num) {\n    case 1:\n        return \"A\";\n    case 2:\n        return \"NS\";\n    case 3:\n        return \"MD\";\n    case 4:\n        return \"MF\";\n    case 5:\n        return \"CNAME\";\n    case 6:\n        return \"SOA\";\n    case 7:\n        return \"MB\";\n    case 8:\n        return \"MG\";\n    case 9:\n        return \"MR\";\n    case 10:\n        return \"NULL\";\n    case 11:\n        return \"WKS\";\n    case 12:\n        return \"PTR\";\n    case 13:\n        return \"HINFO\";\n    case 14:\n        return \"MINFO\";\n    case 15:\n        return \"MX\";\n    case 16:\n        return \"TXT\";\n    case 28:\n        return \"AAAA\";\n    default:\n        return (\"Unknown (\" + type_num + \")\");\n    }\n}\n\nfunction qtype_to_string(qtype_num) {\n    switch (qtype_num) {\n    case 252:\n        return \"AXFR\";\n    case 253:\n        return \"MAILB\";\n    case 254:\n        return \"MAILA\";\n    case 255:\n        return \"*\";\n    default:\n        return type_to_string(qtype_num);\n    }\n}\n\nfunction class_to_string(class_num) {\n    switch (class_num) {\n    case 1:\n        return \"IN\";\n    case 2:\n        return \"CS\";\n    case 3:\n        return \"CH\";\n    case 4:\n        return \"HS\";\n    default:\n        return \"Unknown (\" + class_num + \")\";\n    }\n}\n\nfunction qclass_to_string(qclass_num) {\n    if (qclass_num === 255) {\n        return \"*\";\n    } else {\n        return class_to_string(qclass_num);\n    }\n}\n\nmodule.exports = DNS;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/ipv6_addr.js":"var map = require(\"../util\").int8_to_hex_nopad;\n\nfunction IPv6Addr() {\n    this.o1 = null;\n    this.o2 = null;\n    this.o3 = null;\n    this.o4 = null;\n    this.o5 = null;\n    this.o6 = null;\n    this.o7 = null;\n    this.o8 = null;\n}\n\nIPv6Addr.prototype.decode = function (raw_packet, offset) {\n    this.o1 = raw_packet.readUInt16LE[offset];\n    this.o2 = raw_packet.readUInt16LE[offset + 2];\n    this.o3 = raw_packet.readUInt16LE[offset + 4];\n    this.o4 = raw_packet.readUInt16LE[offset + 6];\n    this.o5 = raw_packet.readUInt16LE[offset + 8];\n    this.o6 = raw_packet.readUInt16LE[offset + 10];\n    this.o7 = raw_packet.readUInt16LE[offset + 12];\n    this.o8 = raw_packet.readUInt16LE[offset + 14];\n\n    return this;\n};\n\nfunction format(num) {\n    var p1 = (num & 0xff00) >> 8;\n    var p2 = num & 0x00ff;\n    if (p1 === 0) {\n        return map[p2];\n    } else {\n        return map[p1] + map[p2];\n    }\n}\n\nIPv6Addr.prototype.toString = function () {\n    return format(this.o1) + \":\" + format(this.o2) + \":\" + format(this.o3) + \":\" + format(this.o4) + \":\" +\n        format(this.o5) + \":\" + format(this.o6) + \":\" + format(this.o7) + \":\" + format(this.o8);\n};\n\nmodule.exports = IPv6Addr;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/ipv6.js":"var ICMP = require(\"./icmp\");\nvar IGMP = require(\"./igmp\");\nvar TCP = require(\"./tcp\");\nvar UDP = require(\"./udp\");\nvar IPv4 = require(\"./ipv4\");\nvar IPv6Addr = require(\"./ipv6_addr\");\n\nfunction IPv6Header() {\n\n}\n\nIPv6Header.prototype.decode = function (raw_packet, next_header, ip, offset) {\n    switch (next_header) {\n    case 1:\n        ip.payload = new ICMP().decode(raw_packet, offset);\n        break;\n    case 2:\n        ip.payload = new IGMP().decode(raw_packet, offset);\n        break;\n    case 4:\n        ip.payload = new IPv4().decode(raw_packet, offset); // IPv4 encapsulation, RFC2003\n        break;\n    case 6:\n        ip.payload = new TCP().decode(raw_packet, offset, ip);\n        break;\n    case 17:\n        ip.payload = new UDP().decode(raw_packet, offset);\n        break;\n    case 41:\n        ip.payload = new IPv6().decode(raw_packet, offset); // IPv6 encapsulation, RFC2473\n        break;\n    /* Please follow numbers and RFC in http://www.iana.org/assignments/ipv6-parameters/ipv6-parameters.xhtml#extension-header\n     * Not all next protocols follow this rule (and we can have unsuported upper protocols here too).\n     *  */\n    case 0: //Hop-by-Hop\n    case 60: //Destination Options\n    case 43: //Routing\n    case 135: //Mobility\n    case 139: //Host Identity Protocol. //Discussion: rfc5201 support only No Next Header/trailing data, but future documents May do.\n    case 140: //Shim6 Protocol\n        new IPv6Header().decode(raw_packet, raw_packet[offset], ip, offset + 8*raw_packet[offset+1] + 8);\n        break;\n    case 51: //Authentication Header\n        new IPv6Header().decode(raw_packet, raw_packet[offset], ip, offset + 4*raw_packet[offset+1] + 8);\n        break;\n    default:\n        // 59 - No next Header, and unknowed upper layer protocols, do nothing.\n    }\n};\n\nfunction IPv6() {\n\n}\n\nIPv6.prototype.decode = function (raw_packet, offset) {\n\n    // http://en.wikipedia.org/wiki/IPv6\n    this.version = (raw_packet[offset] & 240) >> 4; // first 4 bits\n    this.traffic_class = ((raw_packet[offset] & 15) << 4) + ((raw_packet[offset+1] & 240) >> 4);\n    this.flow_label = ((raw_packet[offset + 1] & 15) << 16) +\n        (raw_packet[offset + 2] << 8) +\n        raw_packet[offset + 3];\n    this.payload_length = raw_packet.readUInt16BE(offset+4, true);\n    this.total_length = this.payload_length + 40;\n    this.next_header = raw_packet[offset+6];\n    this.hop_limit = raw_packet[offset+7];\n    this.saddr = new IPv6Addr().decode(raw_packet, offset+8);\n    this.daddr = new IPv6Addr().decode(raw_packet, offset+24);\n    this.header_bytes = 40;\n\n    new IPv6Header().decode(raw_packet, this.next_header, this, offset+40);\n    return this;\n};\n\nIPv6.prototype.toString = function () {\n    var ret = this.saddr + \" -> \" + this.daddr;\n\n    switch (this.next_header) {\n    case 1:\n        ret += \" ICMP\";\n        break;\n    case 2:\n        ret += \" IGMP\";\n        break;\n    case 4:\n        ret += \" IPv4_in_IPv6\"; // IPv4 encapsulation, RFC2003\n        break;\n    case 6:\n        ret += \" TCP\";\n        break;\n    case 17:\n        ret += \" UDP\";\n        break;\n    case 41:\n        ret += \" IPv6_in_IPv6\"; // IPv6 encapsulation, RFC2473\n        break;\n    default:\n        ret += \" proto \" + this.next_header;\n    }\n\n    return ret + \" \" + this.payload;\n};\n\nmodule.exports = IPv6;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/arp.js":"var EthernetAddr = require(\"./ethernet_addr\");\nvar IPv4Addr = require(\"./ipv4_addr\");\n\nfunction Arp() {\n    this.htype = null;\n    this.ptype = null;\n    this.heln = null;\n    this.plen = null;\n    this.operation = null;\n    this.sender_ha = null;\n    this.sender_pa = null;\n    this.target_ha = null;\n    this.target_pa = null;\n}\n\n// http://en.wikipedia.org/wiki/Address_Resolution_Protocol\nArp.prototype.decode = function (raw_packet, offset) {\n    this.htype = raw_packet.readUInt16BE(offset);\n    this.ptype = raw_packet.readUInt16BE(offset + 2);\n    this.hlen = raw_packet[offset + 4];\n    this.plen = raw_packet[offset + 5];\n    this.operation = raw_packet.readUInt16BE(offset + 6); // 6, 7\n    if (this.hlen === 6 && this.plen === 4) { // ethernet + IPv4\n        this.sender_ha = new EthernetAddr(raw_packet, offset + 8); // 8, 9, 10, 11, 12, 13\n        this.sender_pa = new IPv4Addr(raw_packet, offset + 14); // 14, 15, 16, 17\n        this.target_ha = new EthernetAddr(raw_packet, offset + 18); // 18, 19, 20, 21, 22, 23\n        this.target_pa = new IPv4Addr(raw_packet, offset + 24); // 24, 25, 26, 27\n    }\n    // don't know how to decode more exotic ARP types yet, but please add them\n\n    return this;\n};\n\nArp.prototype.toString = function () {\n    var ret = \"\";\n    if (this.operation === 1) {\n        ret += \"request\";\n    } else if (this.operation === 2) {\n        ret += \"reply\";\n    } else {\n        ret += \"unknown\";\n    }\n\n    if (this.sender_ha && this.sender_pa) {\n        ret += \" sender \" + this.sender_ha + \" \" + this.sender_pa + \" target \" + this.target_ha +\n            \" \" + this.target_pa;\n    }\n\n    return ret;\n};\n\nmodule.exports = Arp;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/ethernet_addr.js":"var util = require(\"../util\");\n\nfunction EthernetAddr(raw_packet, offset) {\n\tthis.addr = new Array(6);\n\tthis.addr[0] = raw_packet[offset];\n\tthis.addr[1] = raw_packet[offset + 1];\n\tthis.addr[2] = raw_packet[offset + 2];\n\tthis.addr[3] = raw_packet[offset + 3];\n\tthis.addr[4] = raw_packet[offset + 4];\n\tthis.addr[5] = raw_packet[offset + 5];\n}\n\nEthernetAddr.prototype.toString = function () {\n\treturn util.int8_to_hex[this.addr[0]] + \":\" +\n\t\tutil.int8_to_hex[this.addr[1]] + \":\" +\n\t\tutil.int8_to_hex[this.addr[2]] + \":\" +\n\t\tutil.int8_to_hex[this.addr[3]] + \":\" +\n\t\tutil.int8_to_hex[this.addr[4]] + \":\" +\n\t\tutil.int8_to_hex[this.addr[5]];\n};\n\nmodule.exports = EthernetAddr;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/ethernet_packet.js":"var EthernetAddr = require(\"./ethernet_addr\");\nvar IPv4 = require(\"./ipv4\");\nvar IPv6 = require(\"./ipv6\");\nvar Arp = require(\"./arp\");\nvar Vlan = require(\"./vlan\");\n\nfunction EthernetPacket() {\n    this.dhost = null;\n    this.shost = null;\n    this.ethertype = null;\n    this.vlan = null;\n    this.payload = null;\n}\n\nEthernetPacket.prototype.decode = function (raw_packet, offset) {\n    this.dhost = new EthernetAddr(raw_packet, offset);\n    offset += 6;\n    this.shost = new EthernetAddr(raw_packet, offset);\n    offset += 6;\n    this.ethertype = raw_packet.readUInt16BE(offset, true);\n    offset += 2;\n\n    if (this.ethertype === 0x8100) { // VLAN-tagged (802.1Q)\n        this.vlan = new Vlan().decode(raw_packet, offset);\n        offset += 2;\n\n        // Update the ethertype\n        this.ethertype = raw_packet.readUInt16BE(offset, true);\n        offset += 2;\n    }\n\n    if (this.ethertype < 1536) {\n        // this packet is actually some 802.3 type without an ethertype\n        this.ethertype = 0;\n    } else {\n        // http://en.wikipedia.org/wiki/EtherType\n        switch (this.ethertype) {\n        case 0x800: // IPv4\n            this.payload = new IPv4().decode(raw_packet, offset);\n            break;\n        case 0x806: // ARP\n            this.payload = new Arp().decode(raw_packet, offset);\n            break;\n        case 0x86dd: // IPv6 - http://en.wikipedia.org/wiki/IPv6\n            this.payload = new IPv6().decode(raw_packet, offset);\n            break;\n        case 0x88cc: // LLDP - http://en.wikipedia.org/wiki/Link_Layer_Discovery_Protocol\n            this.payload = \"need to implement LLDP\";\n            break;\n        default:\n            console.log(\"node_pcap: EthernetFrame() - Don't know how to decode ethertype \" + this.ethertype);\n        }\n    }\n\n    return this;\n};\n\nEthernetPacket.prototype.toString = function () {\n    var ret = this.shost + \" -> \" + this.dhost;\n    if (this.vlan) {\n        ret += \" vlan \" + this.vlan;\n    }\n    switch (this.ethertype) {\n    case 0x800:\n        ret += \" IPv4\";\n        break;\n    case 0x806:\n        ret += \" ARP\";\n        break;\n    case 0x86dd:\n        ret += \" IPv6\";\n        break;\n    case 0x88cc:\n        ret += \" LLDP\";\n        break;\n    default:\n        ret += \" ethertype \" + this.ethertype;\n    }\n    return ret + \" \" + this.payload.toString();\n};\n\nmodule.exports = EthernetPacket;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/vlan.js":"function Vlan() {\n\tthis.priority = null;\n\tthis.canonical_format = null;\n\tthis.id = null;\n}\n\n// http://en.wikipedia.org/wiki/IEEE_802.1Q\nVlan.prototype.decode = function (raw_packet, offset) {\n    this.priority = (raw_packet[offset] & 0xE0) >> 5;\n    this.canonical_format = (raw_packet[offset] & 0x10) >> 4;\n    this.id = ((raw_packet[offset] & 0x0F) << 8) | raw_packet[offset + 1];\n\n    return this;\n};\n\nVlan.prototype.toString = function () {\n\treturn this.priority + \" \" + this.canonical_format + \" \" + this.id;\n};\n\nmodule.exports = Vlan;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/llc_packet.js":"var IPv4 = require(\"./ipv4\");\n\nfunction LogicalLinkControl() {\n    this.dsap = null;\n    this.ssap = null;\n    this.control_field = null;\n    this.org_code = null;\n    this.type = null;\n}\n\nLogicalLinkControl.prototype.decode = function (raw_packet, offset) {\n    this.dsap = raw_packet[offset++];\n    this.ssap = raw_packet[offset++];\n\n    if (((this.dsap === 0xaa) && (this.ssap === 0xaa)) || ((this.dsap === 0x00) && (this.ssap === 0x00))) {\n        this.control_field = raw_packet[offset++];\n        this.org_code = [\n            raw_packet[offset++],\n            raw_packet[offset++],\n            raw_packet[offset++]\n        ];\n        this.type = raw_packet.readUInt16BE(raw_packet, offset);\n        offset += 2;\n\n        switch (this.type) {\n        case 0x0800: // IPv4\n            this.payload = new IPv4().decode(raw_packet, offset);\n            break;\n        }\n    } else {\n        throw new Error(\"Unknown LLC types: DSAP: \" + this.dsap + \", SSAP: \" + this.ssap);\n    }\n\n    return this;\n};\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/null_packet.js":"var IPv4 = require(\"./ipv4\");\nvar IPv6 = require(\"./ipv6\");\n\nfunction NullPacket() {\n    this.pftype = null;\n    this.payload = null;\n}\n\n// an oddity about nulltype is that it starts with a 4 byte header, but I can't find a\n// way to tell which byte order is used.  The good news is that all address family\n// values are 8 bits or less.\nNullPacket.prototype.decode = function (raw_packet, offset) {\n    if (raw_packet[offset] === 0 && raw_packet[offset + 1] === 0) { // must be one of the endians\n        this.pftype = raw_packet[offset + 3];\n    } else {                                          // and this is the other one\n        this.pftype = raw_packet[offset];\n    }\n\n    if (this.pftype === 2) {         // AF_INET, at least on my Linux and OSX machines right now\n        this.payload = new IPv4().decode(raw_packet, offset + 4);\n    } else if (this.pftype === 30) { // AF_INET6, often\n        this.payload = new IPv6().decode(raw_packet, offset + 4);\n    } else {\n        console.log(\"pcap.js: decode.nulltype() - Don't know how to decode protocol family \" + this.pftype);\n    }\n\n    return this;\n};\n\nNullPacket.prototype.toString = function () {\n    return this.pftype + \" \" + this.payload;\n};\n\nmodule.exports = NullPacket;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/pcap_packet.js":"var EthernetPacket = require(\"./ethernet_packet\");\nvar NullPacket = require(\"./null_packet\");\nvar RawPacket = require(\"./raw_packet\");\nvar RadioPacket = require(\"./radio_packet\");\nvar SLLPacket = require(\"./sll_packet\");\n\n// Setting properties from the C++ side is very slow, so we send in a shared Buffer.\n// The C++ side does this:\n//   memcpy(session->header_data, &(pkthdr->ts.tv_sec), 4);\n//   memcpy(session->header_data + 4, &(pkthdr->ts.tv_usec), 4);\n//   memcpy(session->header_data + 8, &(pkthdr->caplen), 4);\n//   memcpy(session->header_data + 12, &(pkthdr->len), 4);\n// And here we unpack those 4 ints from the buffer.\n\nfunction PcapHeader(raw_header) {\n    this.tv_sec = raw_header.readUInt32LE(0, true);\n    this.tv_usec = raw_header.readUInt32LE(4, true);\n    this.caplen = raw_header.readUInt32LE(8, true);\n    this.len = raw_header.readUInt32LE(12, true);\n}\n\nfunction PcapPacket() {\n    this.link_type = null;\n    this.pcap_header = null;\n    this.payload = null;\n}\n\nPcapPacket.prototype.decode = function (packet_with_header) {\n    this.link_type = packet_with_header.link_type;\n    this.pcap_header = new PcapHeader(packet_with_header.header);\n\n    var buf = packet_with_header.buf;\n\n    switch (this.link_type) {\n    case \"LINKTYPE_ETHERNET\":\n        this.payload = new EthernetPacket().decode(buf, 0);\n        break;\n    case \"LINKTYPE_NULL\":\n        this.payload = new NullPacket().decode(buf, 0);\n        break;\n    case \"LINKTYPE_RAW\":\n        this.payload = new RawPacket().decode(buf, 0);\n        break;\n    case \"LINKTYPE_IEEE802_11_RADIO\":\n        this.payload = new RadioPacket.decode(buf, 0);\n        break;\n    case \"LINKTYPE_LINUX_SLL\":\n        this.payload = new SLLPacket().decode(buf, 0);\n        break;\n    default:\n        console.log(\"node_pcap: PcapPacket.decode - Don't yet know how to decode link type \" + this.link_type);\n    }\n\n    return this;\n};\n\nPcapPacket.prototype.toString = function () {\n    return this.link_type + \" \" + this.payload;\n};\n\nmodule.exports = PcapPacket;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/raw_packet.js":"var IPv4 = require(\"./ipv4\");\n\nfunction RawPacket() {\n\tthis.payload = null;\n}\n\nRawPacket.prototype.decode = function (raw_packet, offset) {\n\tthis.payload = new IPv4().decode(raw_packet, offset);\n\treturn this;\n};\n\nmodule.exports = RawPacket;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/radio_packet.js":"var RadioFrame = require('./radio_frame');\n\nfunction RadioPacket() {\n\n}\n\nRadioPacket.prototype.decode = function (raw_packet, offset) {\n    var ret = {};\n    var original_offset = offset;\n\n    ret.headerRevision = raw_packet[offset++];\n    ret.headerPad = raw_packet[offset++];\n    ret.headerLength = raw_packet.readUInt16BE(offset, true); offset += 2;\n\n    offset = original_offset + ret.headerLength;\n\n    ret.ieee802_11Frame = new RadioFrame().decode(raw_packet, offset);\n\n    if(ret.ieee802_11Frame && ret.ieee802_11Frame.llc && ret.ieee802_11Frame.llc.ip) {\n        ret.ip = ret.ieee802_11Frame.llc.ip;\n        delete ret.ieee802_11Frame.llc.ip;\n        ret.shost = ret.ieee802_11Frame.shost;\n        delete ret.ieee802_11Frame.shost;\n        ret.dhost = ret.ieee802_11Frame.dhost;\n        delete ret.ieee802_11Frame.dhost;\n    }\n\n    return ret;\n};\n\nmodule.exports = RadioPacket;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/radio_frame.js":"var EthernetAddr = require('./ethernet_addr');\nvar LogicalLinkControl = require('./llc_packet');\n\nfunction RadioFrame() {\n\n}\n\nRadioFrame.prototype.decode = function (raw_packet, offset) {\n    var ret = {};\n\n    ret.frameControl = raw_packet.readUInt16BE(offset, true);\n    offset += 2;\n    ret.type = (ret.frameControl >> 2) & 0x0003;\n    ret.subType = (ret.frameControl >> 4) & 0x000f;\n    ret.flags = (ret.frameControl >> 8) & 0xff;\n    ret.duration = raw_packet.readUInt16BE(offset, true); offset += 2;\n    ret.bssid = new EthernetAddr(raw_packet, offset); offset += 6;\n    ret.shost = new EthernetAddr(raw_packet, offset); offset += 6;\n    ret.dhost = new EthernetAddr(raw_packet, offset); offset += 6;\n    ret.fragSeq = raw_packet.readUInt16BE(offset, true); offset += 2;\n\n    var strength = raw_packet[22];\n    ret.strength = -Math.abs(265 - strength);\n\n\n    switch(ret.subType) {\n        case 8: // QoS Data\n            ret.qosPriority = raw_packet[offset++];\n            ret.txop = raw_packet[offset++];\n            break;\n    }\n\n    if (ret.type == 2 && ret.subType == 4) {\n        // skip this is Null function (No data)\n    } else if (ret.type == 2 && ret.subType == 12) {\n        // skip this is QoS Null function (No data)\n    } else if (ret.type == 2 && ret.subType == 7) {\n        // skip this is CF-Ack/Poll\n    } else if (ret.type == 2 && ret.subType == 6) {\n        // skip this is CF-Poll (No data)\n    } else if (ret.type == 2) { // data\n        ret.llc = new LogicalLinkControl.decode(raw_packet, offset);\n    }\n\n    return ret;\n};\n\nmodule.exports = RadioFrame;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/sll_packet.js":"// Synthetic Link Layer used by Linux to support the \"any\" pseudo device\n// http://www.tcpdump.org/linktypes/LINKTYPE_LINUX_SLL.html\n\nvar SLLAddr = require(\"./sll_addr\");\nvar IPv4 = require(\"./ipv4\");\nvar IPv6 = require(\"./ipv6\");\nvar Arp = require(\"./arp\");\n\nfunction SLLPacket () {\n    this.packet_type = null;\n    this.address_type = null;\n    this.address_len = null;\n    this.address = null;\n    this.ethertype = null;\n    this.payload = null;\n}\n\nSLLPacket.prototype.decode = function (raw_packet, offset) {\n    this.packet_type = raw_packet.readUInt16BE(offset);\n    offset += 2;\n    this.address_type = raw_packet.readUInt16BE(offset);\n    offset += 2;\n    this.address_len = raw_packet.readUInt16BE(offset);\n    offset += 2;\n    this.address = new SLLAddr(raw_packet, offset, this.address_len);\n    offset += 8; // address uses 8 bytes in frame, but only address_len bytes are significant\n    this.ethertype = raw_packet.readUInt16BE(offset);\n    offset += 2;\n\n    if (this.ethertype < 1536) {\n        // this packet is actually some 802.3 type without an ethertype\n        this.ethertype = 0;\n    } else {\n        // http://en.wikipedia.org/wiki/EtherType\n        switch (this.ethertype) {\n        case 0x800: // IPv4\n            this.payload = new IPv4().decode(raw_packet, offset);\n            break;\n        case 0x806: // ARP\n            this.payload = new Arp().decode(raw_packet, offset);\n            break;\n        case 0x86dd: // IPv6 - http://en.wikipedia.org/wiki/IPv6\n            this.payload = new IPv6().decode(raw_packet, offset);\n            break;\n        case 0x88cc: // LLDP - http://en.wikipedia.org/wiki/Link_Layer_Discovery_Protocol\n            this.payload = \"need to implement LLDP\";\n            break;\n        default:\n            console.log(\"node_pcap: SLLPacket() - Don't know how to decode ethertype \" + this.ethertype);\n        }\n    }\n\n    return this;\n};\n\nSLLPacket.prototype.toString = function () {\n    var ret = \"\";\n\n    switch (this.packet_type) {\n    case 0:\n        ret += \"recv_us\";\n        break;\n    case 1:\n        ret += \"broadcast\";\n        break;\n    case 2:\n        ret += \"multicast\";\n        break;\n    case 3:\n        ret += \"remote_remote\";\n        break;\n    case 4:\n        ret += \"sent_us\";\n        break;\n    }\n\n    ret += \" addrtype \" + this.address_type;\n\n    ret += \" \" + this.address;\n\n    switch (this.ethertype) {\n    case 0x800:\n        ret += \" IPv4\";\n        break;\n    case 0x806:\n        ret += \" ARP\";\n        break;\n    case 0x86dd:\n        ret += \" IPv6\";\n        break;\n    case 0x88cc:\n        ret += \" LLDP\";\n        break;\n    default:\n        ret += \" ethertype \" + this.ethertype;\n    }\n\n    return ret + \" \" + this.payload.toString();\n};\n\nmodule.exports = SLLPacket;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/sll_addr.js":"var util = require(\"../util\");\n\nfunction SLLAddr(raw_packet, offset, len) {\n\tthis.addr = new Array(len);\n    for (var i = 0; i < len; i++) {\n    \tthis.addr[i] = raw_packet[offset + i];\n    }\n}\n\nSLLAddr.prototype.toString = function () {\n\tvar ret = \"\";\n\tfor (var i = 0; i < this.addr.length - 1; i++) {\n\t\tret += util.int8_to_hex[this.addr[i]] + \":\";\n\t}\n\tret += util.int8_to_hex[this.addr[i + 1]];\n\treturn ret;\n};\n\nmodule.exports = SLLAddr;\n","/home/travis/build/npmtest/node-npmtest-pcap/node_modules/pcap/decode/websocket.js":"// Meaningfully hold the different types of frames at some point\nfunction WebSocketFrame() {\n    this.type = null;\n    this.data = \"\";\n}\n\nfunction WebSocketParser(flag) {\n    this.buffer = new Buffer(64 * 1024); // 64KB is the max message size\n    this.buffer.end = 0;\n    if (flag === \"draft76\") {\n        this.state = \"skip_response\";\n        this.skipped_bytes = 0;\n    } else {\n        this.state = \"frame_type\";\n    }\n    this.frame = new WebSocketFrame();\n\n    events.EventEmitter.call(this);\n}\nrequire(\"util\").inherits(WebSocketParser, require(\"events\").EventEmitter);\n\nWebSocketParser.prototype.execute = function (incoming_buf) {\n    var pos = 0;\n\n    while (pos < incoming_buf.length) {\n        switch (this.state) {\n        case \"skip_response\":\n            this.skipped_bytes += 1;\n            if (this.skipped_bytes === 16) {\n                this.state = \"frame_type\";\n            }\n            pos += 1;\n            break;\n        case \"frame_type\":\n            this.frame.type = incoming_buf[pos];\n            pos += 1;\n            this.state = \"read_until_marker\";\n            break;\n        case \"read_until_marker\":\n            if (incoming_buf[pos] !== 255) {\n                this.buffer[this.buffer.end] = incoming_buf[pos];\n                this.buffer.end += 1;\n                pos += 1;\n            } else {\n                this.frame.data = this.buffer.toString(\"utf8\", 0, this.buffer.end);\n                this.emit(\"message\", this.frame.data); // this gets converted to \"websocket message\" in TCP_Tracker\n                this.state = \"frame_type\";\n                this.buffer.end = 0;\n                pos += 1;\n            }\n            break;\n        default:\n            throw new Error(\"invalid state \" + this.state);\n        }\n    }\n};\n\nmodule.exports = WebSocketParser;\n"}